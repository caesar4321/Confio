import algosdk from 'algosdk';
import { Buffer } from 'buffer';
import { ALGORAND_NETWORKS } from '../config/web3auth';
import { web3AuthService } from './web3AuthService';
import * as Keychain from 'react-native-keychain';

export interface AlgorandAccount {
  address: string;
  privateKey: Uint8Array;
  mnemonic?: string;
}

export interface AlgorandBalance {
  amount: number;
  amountWithoutPendingRewards: number;
  pendingRewards: number;
  minimumBalance: number;
  assets?: any[];
}

export interface AlgorandTransaction {
  from: string;
  to: string;
  amount: number;
  note?: string;
  fee?: number;
}

const KEYCHAIN_SERVICE = 'com.confio.algorand';
const KEYCHAIN_USERNAME = 'algorand_account';

export class AlgorandWalletService {
  private static instance: AlgorandWalletService;
  private client: algosdk.Algodv2 | null = null;
  private indexer: algosdk.Indexer | null = null;
  private currentAccount: AlgorandAccount | null = null;
  private network: 'mainnet' | 'testnet' | 'betanet' = 'mainnet';

  private constructor() {}

  public static getInstance(): AlgorandWalletService {
    if (!AlgorandWalletService.instance) {
      AlgorandWalletService.instance = new AlgorandWalletService();
    }
    return AlgorandWalletService.instance;
  }

  public async initialize(network: 'mainnet' | 'testnet' | 'betanet' = 'mainnet'): Promise<void> {
    try {
      console.log(`Initializing Algorand wallet service on ${network}...`);
      
      this.network = network;
      const networkConfig = ALGORAND_NETWORKS[network];
      
      // Initialize Algorand client
      this.client = new algosdk.Algodv2('', networkConfig.rpcUrl, networkConfig.port);
      
      // Initialize indexer for querying
      this.indexer = new algosdk.Indexer('', networkConfig.indexerUrl, networkConfig.port);
      
      // Try to restore previous account
      await this.restoreAccount();
      
      console.log('Algorand wallet service initialized successfully');
    } catch (error) {
      console.error('Failed to initialize Algorand wallet service:', error);
      throw error;
    }
  }

  public async createAccountFromWeb3Auth(): Promise<AlgorandAccount> {
    try {
      console.log('AlgorandWalletService - Creating Algorand account from Web3Auth...');
      
      // CRITICAL: Clear any existing account first to prevent address reuse
      if (this.currentAccount) {
        console.log('AlgorandWalletService - Clearing existing account before creating new one');
        this.currentAccount = null;
      }
      
      // Get private key from Web3Auth (this will be a secp256k1 key from SFA)
      const privateKey = await web3AuthService.getPrivateKey();
      if (!privateKey) {
        throw new Error('No private key available from Web3Auth');
      }

      console.log('AlgorandWalletService - Got Web3Auth private key');
      console.log('AlgorandWalletService - Private key (first 10 chars):', privateKey.substring(0, 10));
      console.log('AlgorandWalletService - Private key length:', privateKey.length);
      console.log('AlgorandWalletService - Private key hash:', this.hashString(privateKey)); // Log a hash for debugging without exposing the key
      
      // For Web3Auth SFA, we need to derive an Algorand account deterministically
      // from the secp256k1 key. We'll use it as a seed to generate an Algorand account
      const account = await this.deriveAlgorandAccountFromSeed(privateKey);
      
      // Store account
      await this.storeAccount(account);
      this.currentAccount = account;
      
      console.log('Algorand account created:', account.address);
      return account;
    } catch (error) {
      console.error('Error creating Algorand account:', error);
      throw error;
    }
  }
  
  private hashString(str: string): string {
    // Simple hash for debugging without exposing sensitive data
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return hash.toString(16);
  }

  private async deriveAlgorandAccountFromSeed(seedHex: string): Promise<AlgorandAccount> {
    try {
      // Remove 0x prefix if present
      if (seedHex.startsWith('0x')) {
        seedHex = seedHex.slice(2);
      }
      
      // Convert hex to bytes
      const seedBytes = this.hexToUint8Array(seedHex);
      
      // IMPORTANT: Create deterministic Algorand account from Web3Auth seed
      // We need to ensure the first 32 bytes are used as the ED25519 private key seed
      // Algorand uses ED25519, so we need exactly 32 bytes for the seed
      
      // Ensure we have exactly 32 bytes (Web3Auth private keys are 32 bytes)
      let seed = seedBytes;
      if (seed.length > 32) {
        seed = seed.slice(0, 32);
      } else if (seed.length < 32) {
        // Pad with zeros if somehow the seed is too short
        const paddedSeed = new Uint8Array(32);
        paddedSeed.set(seed);
        seed = paddedSeed;
      }
      
      // Create an Algorand account from the seed deterministically
      // We'll use the seed to generate a mnemonic, then create account from mnemonic
      // This ensures the same seed always produces the same Algorand address
      
      try {
        // First, try to use the seed directly as an ED25519 private key
        // Algorand's sk (secret key) is 64 bytes: 32 bytes seed + 32 bytes public key
        const { default: nacl } = await import('tweetnacl');
        
        // Generate ED25519 keypair from seed
        const keyPair = nacl.sign.keyPair.fromSeed(seed);
        
        // Algorand's secret key format is seed (32 bytes) + public key (32 bytes)
        const sk = new Uint8Array(64);
        sk.set(seed, 0); // First 32 bytes: seed
        sk.set(keyPair.publicKey, 32); // Last 32 bytes: public key
        
        // Get the Algorand address from the public key
        const address = algosdk.encodeAddress(keyPair.publicKey);
        
        // Generate mnemonic from the secret key
        const mnemonic = algosdk.secretKeyToMnemonic(sk);
        
        console.log('Algorand account derived deterministically from Web3Auth seed');
        console.log('Address:', address);
        
        return {
          address: address,
          privateKey: sk,
          mnemonic: mnemonic,
        };
      } catch (naclError) {
        console.error('Error using nacl for deterministic derivation:', naclError);
        // Fall back to using algosdk's mnemonic generation
        
        // Convert seed to mnemonic (this is deterministic)
        const mnemonic = algosdk.secretKeyToMnemonic(new Uint8Array([...seed, ...seed]));
        const account = algosdk.mnemonicToSecretKey(mnemonic);
        
        return {
          address: account.addr,
          privateKey: account.sk,
          mnemonic: mnemonic,
        };
      }
    } catch (error) {
      console.error('Error deriving Algorand account from seed:', error);
      
      // CRITICAL: DO NOT generate random account as fallback!
      // This would cause different addresses for the same user
      throw new Error('Failed to derive Algorand account from Web3Auth seed');
    }
  }

  public async getBalance(address?: string): Promise<AlgorandBalance> {
    try {
      if (!this.client) {
        throw new Error('Algorand client not initialized');
      }

      const targetAddress = address || this.currentAccount?.address;
      if (!targetAddress) {
        throw new Error('No address available');
      }

      console.log(`Getting balance for ${targetAddress}...`);
      
      const accountInfo = await this.client.accountInformation(targetAddress).do();
      
      return {
        amount: accountInfo.amount / 1000000, // Convert microAlgos to Algos
        amountWithoutPendingRewards: accountInfo.amountWithoutPendingRewards / 1000000,
        pendingRewards: accountInfo.pendingRewards / 1000000,
        minimumBalance: accountInfo.minBalance / 1000000,
        assets: accountInfo.assets,
      };
    } catch (error) {
      console.error('Error getting balance:', error);
      throw error;
    }
  }

  public async sendTransaction(transaction: AlgorandTransaction): Promise<string> {
    try {
      if (!this.client || !this.currentAccount) {
        throw new Error('Algorand client or account not initialized');
      }

      console.log('Sending Algorand transaction...');
      
      // Get suggested params
      const params = await this.client.getTransactionParams().do();
      
      // Create transaction
      const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
        from: transaction.from || this.currentAccount.address,
        to: transaction.to,
        amount: transaction.amount * 1000000, // Convert Algos to microAlgos
        note: transaction.note ? new TextEncoder().encode(transaction.note) : undefined,
        suggestedParams: params,
      });

      // Sign transaction
      const signedTxn = txn.signTxn(this.currentAccount.privateKey);
      
      // Submit transaction
      const { txId } = await this.client.sendRawTransaction(signedTxn).do();
      
      // Wait for confirmation
      await algosdk.waitForConfirmation(this.client, txId, 4);
      
      console.log('Transaction confirmed:', txId);
      return txId;
    } catch (error) {
      console.error('Error sending transaction:', error);
      throw error;
    }
  }

  public async getTransactionHistory(address?: string, limit: number = 10): Promise<any[]> {
    try {
      if (!this.indexer) {
        throw new Error('Algorand indexer not initialized');
      }

      const targetAddress = address || this.currentAccount?.address;
      if (!targetAddress) {
        throw new Error('No address available');
      }

      console.log(`Getting transaction history for ${targetAddress}...`);
      
      const transactions = await this.indexer
        .searchForTransactions()
        .address(targetAddress)
        .limit(limit)
        .do();
      
      return transactions.transactions || [];
    } catch (error) {
      console.error('Error getting transaction history:', error);
      throw error;
    }
  }

  public async createAsset(
    assetName: string,
    unitName: string,
    totalSupply: number,
    decimals: number = 0
  ): Promise<string> {
    try {
      if (!this.client || !this.currentAccount) {
        throw new Error('Algorand client or account not initialized');
      }

      console.log(`Creating asset ${assetName}...`);
      
      // Get suggested params
      const params = await this.client.getTransactionParams().do();
      
      // Create asset creation transaction
      const txn = algosdk.makeAssetCreateTxnWithSuggestedParamsFromObject({
        from: this.currentAccount.address,
        total: totalSupply,
        decimals,
        defaultFrozen: false,
        unitName,
        assetName,
        manager: this.currentAccount.address,
        reserve: this.currentAccount.address,
        freeze: this.currentAccount.address,
        clawback: this.currentAccount.address,
        suggestedParams: params,
      });

      // Sign transaction
      const signedTxn = txn.signTxn(this.currentAccount.privateKey);
      
      // Submit transaction
      const { txId } = await this.client.sendRawTransaction(signedTxn).do();
      
      // Wait for confirmation
      const confirmedTxn = await algosdk.waitForConfirmation(this.client, txId, 4);
      
      const assetId = confirmedTxn['asset-index'];
      console.log('Asset created with ID:', assetId);
      
      return assetId.toString();
    } catch (error) {
      console.error('Error creating asset:', error);
      throw error;
    }
  }

  public async optInToAsset(assetId: number): Promise<string> {
    try {
      if (!this.client || !this.currentAccount) {
        throw new Error('Algorand client or account not initialized');
      }

      console.log(`Opting in to asset ${assetId}...`);
      
      // Get suggested params
      const params = await this.client.getTransactionParams().do();
      
      // Create opt-in transaction (0 amount transfer to self)
      const txn = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({
        from: this.currentAccount.address,
        to: this.currentAccount.address,
        amount: 0,
        assetIndex: assetId,
        suggestedParams: params,
      });

      // Sign transaction
      const signedTxn = txn.signTxn(this.currentAccount.privateKey);
      
      // Submit transaction
      const { txId } = await this.client.sendRawTransaction(signedTxn).do();
      
      // Wait for confirmation
      await algosdk.waitForConfirmation(this.client, txId, 4);
      
      console.log('Opted in to asset:', assetId);
      return txId;
    } catch (error) {
      console.error('Error opting in to asset:', error);
      throw error;
    }
  }

  public getCurrentAccount(): AlgorandAccount | null {
    return this.currentAccount;
  }

  public getAddress(): string | null {
    return this.currentAccount?.address || null;
  }

  public async exportMnemonic(): Promise<string | null> {
    if (!this.currentAccount) {
      return null;
    }
    return this.currentAccount.mnemonic || null;
  }

  private hexToUint8Array(hex: string): Uint8Array {
    if (hex.startsWith('0x')) {
      hex = hex.slice(2);
    }
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < bytes.length; i++) {
      bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
    }
    return bytes;
  }

  private async storeAccount(account: AlgorandAccount): Promise<void> {
    try {
      // Don't store private key or mnemonic directly for security
      const accountData = {
        address: account.address,
        network: this.network,
      };
      
      await Keychain.setInternetCredentials(
        KEYCHAIN_SERVICE,
        KEYCHAIN_USERNAME,
        JSON.stringify(accountData)
      );
      
      console.log('Algorand account stored successfully');
    } catch (error) {
      console.error('Error storing Algorand account:', error);
    }
  }

  private async restoreAccount(): Promise<void> {
    try {
      const credentials = await Keychain.getInternetCredentials(KEYCHAIN_SERVICE);
      
      if (credentials && credentials.password) {
        const accountData = JSON.parse(credentials.password);
        
        // Try to restore full account from Web3Auth
        const privateKey = await web3AuthService.getPrivateKey();
        if (privateKey) {
          const account = await this.deriveAlgorandAccountFromSeed(privateKey);
          
          // Note: Since we're generating a new account each time (not deterministic yet),
          // the address won't match. For now, we'll just use the new account.
          // In production, you'd want to store the actual Algorand private key securely
          // or implement proper deterministic derivation
          this.currentAccount = account;
          console.log('Algorand account restored (new account generated)');
        }
      }
    } catch (error) {
      console.error('Error restoring Algorand account:', error);
    }
  }

  public async clearAccount(): Promise<void> {
    try {
      // Try to get existing credentials first
      const existing = await Keychain.getInternetCredentials(KEYCHAIN_SERVICE);
      if (existing) {
        // If they exist, overwrite with dummy data
        await Keychain.setInternetCredentials(
          KEYCHAIN_SERVICE,
          'cleared',
          'cleared'
        );
      }
      
      // Clear all internal state
      this.currentAccount = null;
      this.client = null;
      this.indexer = null;
      
      // CRITICAL: Reset the singleton instance to force complete re-initialization
      AlgorandWalletService.instance = null as any;
      
      console.log('Algorand account and singleton cleared');
    } catch (error) {
      // Credentials might not exist, which is fine
      console.log('No Algorand account to clear');
      // Still clear internal state
      this.currentAccount = null;
      this.client = null;
      this.indexer = null;
      // Reset singleton even on error
      AlgorandWalletService.instance = null as any;
    }
  }

  public async signTransaction(encodedTxn: string): Promise<Uint8Array> {
    try {
      if (!this.currentAccount) {
        throw new Error('No Algorand account available for signing');
      }

      console.log('Signing transaction...');
      
      // Decode the base64 encoded transaction
      const txnBytes = Buffer.from(encodedTxn, 'base64');
      
      // Decode the msgpack transaction
      const msgpack = require('algosdk/dist/cjs/src/encoding/msgpack');
      const txnObj = msgpack.decode(txnBytes);
      
      // Create transaction from decoded object
      const txn = algosdk.Transaction.from_obj_for_encoding(txnObj);
      
      // Sign the transaction
      const signedTxn = txn.signTxn(this.currentAccount.privateKey);
      
      console.log('Transaction signed successfully');
      return signedTxn;
    } catch (error) {
      console.error('Error signing transaction:', error);
      throw error;
    }
  }

  public async submitTransaction(signedTxn: Uint8Array): Promise<string> {
    try {
      if (!this.client) {
        throw new Error('Algorand client not initialized');
      }

      console.log('Submitting transaction to Algorand network...');
      
      // Submit the signed transaction
      const { txId } = await this.client.sendRawTransaction(signedTxn).do();
      
      // Wait for confirmation
      await algosdk.waitForConfirmation(this.client, txId, 4);
      
      console.log('Transaction confirmed:', txId);
      return txId;
    } catch (error) {
      console.error('Error submitting transaction:', error);
      throw error;
    }
  }
}

// Export singleton instance
export const algorandWalletService = AlgorandWalletService.getInstance();