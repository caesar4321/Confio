// Import polyfills first
import './web3AuthPolyfills';

import Web3Auth from '@web3auth/single-factor-auth';
import { CHAIN_NAMESPACES, WEB3AUTH_NETWORK } from '@web3auth/base';
import * as Keychain from 'react-native-keychain';
import { WEB3AUTH_CONFIG } from '../config/web3auth';

export interface Web3AuthUser {
  email?: string;
  name?: string;
  profileImage?: string;
  aggregateVerifier?: string;
  verifier?: string;
  verifierId?: string;
  typeOfLogin?: string;
  dappShare?: string;
  idToken?: string;
  oAuthIdToken?: string;
  oAuthAccessToken?: string;
  privateKey?: string;
}

export interface Web3AuthSession {
  user: Web3AuthUser;
  privateKey: string;
  ed25519PrivKey?: string;
  sessionId?: string;
}

const KEYCHAIN_SERVICE = 'com.confio.web3auth';
const KEYCHAIN_USERNAME = 'web3auth_session';

export class Web3AuthService {
  private static instance: Web3AuthService;
  private web3auth: Web3Auth | null = null;
  private isInitialized = false;
  private currentSession: Web3AuthSession | null = null;

  private constructor() {}

  public static getInstance(): Web3AuthService {
    if (!Web3AuthService.instance) {
      Web3AuthService.instance = new Web3AuthService();
    }
    return Web3AuthService.instance;
  }

  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      console.log('Web3Auth already initialized');
      return;
    }

    try {
      // Validate config exists
      if (!WEB3AUTH_CONFIG || !WEB3AUTH_CONFIG.clientId) {
        throw new Error('Web3Auth configuration is missing or invalid. ClientId is required.');
      }

      console.log('Web3Auth SFA - Initializing with config:', {
        clientId: WEB3AUTH_CONFIG.clientId ? WEB3AUTH_CONFIG.clientId.substring(0, 20) + '...' : 'undefined',
        network: WEB3AUTH_CONFIG.network,
      });
      
      // For React Native, we need additional setup
      // Import required Web3Auth modules dynamically
      const { CommonPrivateKeyProvider } = await import('@web3auth/base-provider');
      const { SDK_MODE, WEB3AUTH_NETWORK: W3A_NETWORK } = await import('@web3auth/base');
      
      // Create private key provider for SFA
      const privateKeyProvider = new CommonPrivateKeyProvider({
        config: {
          chainConfig: {
            chainNamespace: CHAIN_NAMESPACES.OTHER,
            chainId: '0x1',
            rpcTarget: WEB3AUTH_CONFIG.algorand.rpcUrl,
          },
        },
      });
      
      // Custom storage adapter for React Native using Keychain
      const storageAdapter = {
        getItem: async (key: string) => {
          try {
            const credentials = await Keychain.getInternetCredentials(`web3auth.${key}`);
            return credentials ? credentials.password : null;
          } catch (error) {
            console.error('Storage getItem error:', error);
            return null;
          }
        },
        setItem: async (key: string, value: string) => {
          try {
            await Keychain.setInternetCredentials(
              `web3auth.${key}`,
              key,
              value
            );
          } catch (error) {
            console.error('Storage setItem error:', error);
          }
        },
        removeItem: async (key: string) => {
          try {
            // Use setInternetCredentials with dummy data instead of reset
            await Keychain.setInternetCredentials(
              `web3auth.${key}`,
              'cleared',
              'cleared'
            );
          } catch (error) {
            console.error('Storage removeItem error:', error);
          }
        }
      };
      
      // Initialize Web3Auth Single Factor Auth instance with React Native support
      try {
        const config: any = {
          clientId: WEB3AUTH_CONFIG.clientId,
          web3AuthNetwork: W3A_NETWORK.SAPPHIRE_DEVNET,
          privateKeyProvider, // Required for SFA
          storage: storageAdapter, // Custom storage for RN
        };
        
        // Add mode only if SDK_MODE is defined
        if (SDK_MODE && SDK_MODE.REACT_NATIVE) {
          config.mode = SDK_MODE.REACT_NATIVE;
        }
        
        this.web3auth = new Web3Auth(config);
      } catch (initError: any) {
        console.error('Web3Auth SFA - Failed to create instance:', initError);
        // If it fails, try without the privateKeyProvider which might not be compatible
        try {
          console.log('Web3Auth SFA - Trying simpler initialization...');
          this.web3auth = new Web3Auth({
            clientId: WEB3AUTH_CONFIG.clientId,
            web3AuthNetwork: 'sapphire_devnet' as any,
          });
        } catch (fallbackError: any) {
          console.error('Web3Auth SFA - Fallback also failed:', fallbackError);
          throw initError;
        }
      }

      console.log('Web3Auth SFA - Calling init()...');
      // Initialize the SDK
      await this.web3auth.init();
      
      this.isInitialized = true;
      console.log('Web3Auth SFA - Initialized successfully');
      
      // DO NOT restore previous session - we want fresh keys for each user
      // await this.restoreSession();
    } catch (error) {
      console.error('Failed to initialize Web3Auth SFA:', error);
      throw error;
    }
  }

  public async login(provider: 'google' | 'apple', idToken?: string): Promise<Web3AuthSession> {
    try {
      // CRITICAL: Force complete logout and re-initialization to prevent key reuse
      console.log('Web3Auth SFA - Forcing complete logout before new login...');
      
      // If there's an existing session or web3auth instance, completely destroy it
      if (this.web3auth) {
        try {
          console.log('Web3Auth SFA - Logging out existing Web3Auth instance...');
          await this.web3auth.logout();
        } catch (logoutError) {
          console.log('Web3Auth SFA - Logout error (continuing):', logoutError);
        }
        
        // Destroy the instance completely
        this.web3auth = null;
        this.isInitialized = false;
        this.currentSession = null;
      }
      
      // Clear any cached session data
      await this.clearSession();
      
      // Force re-initialization with fresh instance
      console.log('Web3Auth SFA - Creating fresh Web3Auth instance...');
      await this.initialize();
      
      console.log(`Web3Auth SFA - Starting fresh login with ${provider}...`);
      
      // For Single Factor Auth, we need to use the verifier and verifierId
      // The verifier should be configured in the Web3Auth dashboard
      let verifier = 'firebase-confio-test'; // Using the Firebase verifier configured in Web3Auth dashboard
      let verifierId = '';
      
      // Extract verifierId from the ID token if available
      if (idToken) {
        try {
          // Decode the ID token to get the user's Firebase UID
          const base64Url = idToken.split('.')[1];
          const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
          const jsonPayload = decodeURIComponent(atob(base64).split('').map(function(c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
          }).join(''));
          
          const payload = JSON.parse(jsonPayload);
          // Use the sub claim which is the Firebase UID
          verifierId = payload.sub || payload.user_id || '';
          console.log('Web3Auth SFA - Extracted verifierId (Firebase UID) from token:', verifierId);
          console.log('Web3Auth SFA - Token sub:', payload.sub);
          console.log('Web3Auth SFA - Token user_id:', payload.user_id);
          console.log('Web3Auth SFA - Token email:', payload.email);
        } catch (error) {
          console.error('Web3Auth SFA - Failed to decode ID token:', error);
        }
      }
      
      if (!verifierId) {
        // If we don't have an ID token, this is a critical error
        // Web3Auth SFA requires the ID token to generate deterministic keys
        throw new Error('ID token required for Web3Auth Single Factor Auth. Please ensure Firebase authentication is completed first.');
      }

      console.log(`Web3Auth SFA - Connecting with verifier: ${verifier}, verifierId: ${verifierId}`);

      // Perform Single Factor Auth login
      // For SFA, we should NOT trigger any OAuth flow - it should be invisible
      let provider_response;
      try {
        // Web3Auth SFA requires the ID token for authentication
        if (!idToken) {
          console.error('Web3Auth SFA - No ID token available, cannot proceed with authentication');
          throw new Error('ID token required for Single Factor Auth. Please ensure Firebase ID token is provided.');
        }
        
        // Check if already connected
        if (this.web3auth.status === 'connected') {
          console.log('Web3Auth SFA - Already connected, getting existing provider...');
          provider_response = this.web3auth.provider;
        } else {
          console.log('Web3Auth SFA - Not connected, connecting...');
          provider_response = await this.web3auth.connect({
            verifier,
            verifierId,
            idToken: idToken,
          });
        }
        console.log('Web3Auth SFA - Connection response received:', !!provider_response);
        console.log('Web3Auth SFA - Response type:', typeof provider_response);
        console.log('Web3Auth SFA - Response keys:', provider_response ? Object.keys(provider_response) : 'null');
      } catch (loginError: any) {
        console.error('Web3Auth SFA - Connection failed:', loginError.message || loginError);
        
        // Check if it's a verifier error
        if (loginError.message?.includes('verifier')) {
          throw new Error(`Web3Auth verifier '${verifier}' not configured. Please ensure it is set up in Web3Auth dashboard.`);
        }
        throw loginError;
      }
      
      if (!provider_response) {
        throw new Error('Login failed - no provider response returned');
      }

      // Get private key from the provider
      // Web3Auth SFA returns a provider that we need to query for the private key
      let privateKey: string;
      
      // Check if provider_response is a provider object with methods
      if (provider_response && typeof provider_response.request === 'function') {
        console.log('Web3Auth SFA - Provider has request method, getting private key...');
        try {
          // Request the private key from the provider
          privateKey = await provider_response.request({
            method: 'eth_private_key', // or 'private_key' for OTHER chain
          });
          console.log('Web3Auth SFA - Got private key from provider');
        } catch (reqError) {
          console.error('Web3Auth SFA - Failed to get private key with eth_private_key:', reqError);
          // Try alternative method
          privateKey = await provider_response.request({
            method: 'private_key',
          });
        }
      } else if (typeof provider_response === 'string') {
        // Provider response is directly the private key
        console.log('Web3Auth SFA - Provider response is the private key');
        privateKey = provider_response;
      } else {
        console.error('Web3Auth SFA - Unknown provider response format');
        throw new Error('Failed to extract private key from provider');
      }
      
      if (!privateKey) {
        throw new Error('Failed to retrieve private key');
      }
      
      console.log('Web3Auth SFA - Private key obtained (first 10 chars):', privateKey.substring(0, 10));

      // For Algorand, we need the ED25519 key
      // SFA returns a secp256k1 key by default, we'll need to derive ED25519
      // For now, we'll use the private key as-is and handle conversion in algorandWalletService
      
      // Get user info
      const userInfo = await this.web3auth.getUserInfo();

      // Create session object
      const session: Web3AuthSession = {
        user: {
          email: userInfo?.email,
          name: userInfo?.name,
          profileImage: userInfo?.profileImage,
          verifier: verifier,
          verifierId: verifierId,
          typeOfLogin: provider,
        },
        privateKey,
        ed25519PrivKey: privateKey, // Will be converted in algorandWalletService
        sessionId: undefined, // SFA doesn't provide sessionId
      };

      // Store session
      await this.storeSession(session);
      this.currentSession = session;

      console.log('Web3Auth SFA login successful');
      return session;
    } catch (error) {
      console.error('Web3Auth SFA login error:', error);
      throw error;
    }
  }

  public async logout(): Promise<void> {
    try {
      console.log('Logging out from Web3Auth SFA...');
      
      // Try to logout from Web3Auth SDK if initialized
      if (this.web3auth) {
        try {
          // Logout from Web3Auth
          await this.web3auth.logout();
          console.log('Web3Auth SDK logout successful');
        } catch (sdkError: any) {
          console.error('Web3Auth SDK logout error:', sdkError?.message || sdkError);
          // Continue with cleanup even if SDK logout fails
        }
      }
      
      // Clear stored session
      await this.clearSession();
      
      // IMPORTANT: Reset all internal state
      this.currentSession = null;
      this.isInitialized = false;
      
      // Force re-initialization on next use by clearing the web3auth instance
      if (this.web3auth) {
        this.web3auth = null;
      }
      
      // CRITICAL: Reset the singleton instance to force complete re-initialization
      Web3AuthService.instance = null as any;
      
      console.log('Web3Auth SFA logout completed - singleton reset');
    } catch (error: any) {
      console.error('Web3Auth SFA logout error:', error?.message || error);
      // Continue with cleanup even if logout fails
      try {
        await this.clearSession();
        this.currentSession = null;
        this.isInitialized = false;
        this.web3auth = null;
        // Reset singleton even on error
        Web3AuthService.instance = null as any;
      } catch (clearError: any) {
        console.error('Failed to clear session:', clearError?.message || clearError);
      }
    }
  }

  public async getPrivateKey(): Promise<string | null> {
    try {
      console.log('Web3Auth SFA - getPrivateKey called');
      
      if (!this.web3auth) {
        console.log('Web3Auth SFA - Not initialized in getPrivateKey');
        throw new Error('Web3Auth not initialized');
      }

      // In SFA, the private key is returned from connect()
      // If we have a current session, return the stored key
      if (this.currentSession?.privateKey) {
        console.log('Web3Auth SFA - Returning private key from currentSession');
        console.log('Web3Auth SFA - Private key (first 10 chars):', this.currentSession.privateKey.substring(0, 10));
        return this.currentSession.privateKey;
      }

      // Try to get from the provider
      const provider = this.web3auth.provider;
      if (provider) {
        console.log('Web3Auth SFA - Getting private key from provider');
        // The provider itself is the private key in SFA
        const key = provider as string;
        console.log('Web3Auth SFA - Private key from provider (first 10 chars):', key.substring(0, 10));
        return key;
      }

      console.log('Web3Auth SFA - No private key available');
      return null;
    } catch (error) {
      console.error('Error getting private key:', error);
      return null;
    }
  }

  public async getEd25519PrivateKey(): Promise<string | null> {
    try {
      // For SFA, we need to derive ED25519 from the secp256k1 key
      // This will be handled in algorandWalletService
      return this.getPrivateKey();
    } catch (error) {
      console.error('Error getting ED25519 private key:', error);
      return null;
    }
  }

  public async getUserInfo(): Promise<Web3AuthUser | null> {
    try {
      if (!this.web3auth) {
        throw new Error('Web3Auth not initialized');
      }

      const userInfo = await this.web3auth.getUserInfo();
      return userInfo as Web3AuthUser;
    } catch (error) {
      console.error('Error getting user info:', error);
      return null;
    }
  }

  public isLoggedIn(): boolean {
    return this.currentSession !== null;
  }

  public getCurrentSession(): Web3AuthSession | null {
    return this.currentSession;
  }

  private async storeSession(session: Web3AuthSession): Promise<void> {
    try {
      await Keychain.setInternetCredentials(
        KEYCHAIN_SERVICE,
        KEYCHAIN_USERNAME,
        JSON.stringify(session)
      );
      console.log('Web3Auth session stored successfully');
    } catch (error) {
      console.error('Error storing Web3Auth session:', error);
    }
  }

  private async restoreSession(): Promise<void> {
    try {
      const credentials = await Keychain.getInternetCredentials(KEYCHAIN_SERVICE);
      
      if (credentials && credentials.password) {
        const session: Web3AuthSession = JSON.parse(credentials.password);
        
        // For SFA, we can't easily verify if session is still valid without reconnecting
        // Just restore the session and let it fail on next operation if invalid
        this.currentSession = session;
        console.log('Web3Auth session restored from storage');
      }
    } catch (error) {
      console.error('Error restoring Web3Auth session:', error);
      await this.clearSession();
    }
  }

  private async clearSession(): Promise<void> {
    try {
      // Try to get existing credentials first
      const existing = await Keychain.getInternetCredentials(KEYCHAIN_SERVICE);
      if (existing) {
        // If they exist, overwrite with dummy data
        await Keychain.setInternetCredentials(
          KEYCHAIN_SERVICE,
          'cleared',
          'cleared'
        );
      }
      console.log('Web3Auth session cleared');
    } catch (error) {
      // Credentials might not exist, which is fine
      console.log('No Web3Auth session to clear');
    }
  }

  // Helper method to integrate with existing auth flow
  public async migrateFromFirebase(firebaseUser: any): Promise<Web3AuthSession> {
    try {
      // Determine provider based on Firebase user
      let provider: 'google' | 'apple' = 'google';
      
      if (firebaseUser.providerData) {
        const providerData = firebaseUser.providerData[0];
        if (providerData.providerId === 'apple.com') {
          provider = 'apple';
        }
      }
      
      // Login with Web3Auth using the same provider
      const session = await this.login(provider);
      
      // You might want to sync additional user data here
      console.log('Successfully migrated user from Firebase to Web3Auth');
      
      return session;
    } catch (error) {
      console.error('Error migrating from Firebase:', error);
      throw error;
    }
  }
}

// Export singleton instance
export const web3AuthService = Web3AuthService.getInstance();