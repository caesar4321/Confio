module p2p_trade::p2p_trade {
    use sui::object::{Self, UID};
    use sui::tx_context::{Self, sender, TxContext};
    use sui::transfer::{Self, public_transfer, share_object};
    use sui::coin::{Self, Coin};
    use sui::balance::{Self, Balance};
    use sui::event;
    use sui::clock::{Self, Clock};
    use sui::table::{Self, Table};
    use std::vector;
    use cusd::cusd::CUSD;
    use confio::confio::CONFIO;

    // Error codes
    const ENotAuthorized: u64 = 1;
    const EInvalidAmount: u64 = 2;
    const ETradeNotFound: u64 = 3;
    const ETradeAlreadyAccepted: u64 = 4;
    const ETradeExpired: u64 = 5;
    const ETradeNotExpired: u64 = 6;
    const ETradeAlreadyCompleted: u64 = 7;
    const ETradeAlreadyCancelled: u64 = 8;
    const ETradeInDispute: u64 = 9;
    const ETradeNotInDispute: u64 = 10;
    const EInvalidTradeState: u64 = 11;
    const ESystemPaused: u64 = 12;
    const ESelfTrade: u64 = 13;

    // Constants
    const TRADE_WINDOW_MS: u64 = 900000; // 15 minutes in milliseconds
    const STATUS_PENDING: u8 = 0;
    const STATUS_ACTIVE: u8 = 1;
    const STATUS_COMPLETED: u8 = 2;
    const STATUS_CANCELLED: u8 = 3;
    const STATUS_DISPUTED: u8 = 4;
    const STATUS_EXPIRED: u8 = 5;

    // Objects
    struct AdminCap has key, store {
        id: UID
    }

    struct TradeRegistry has key {
        id: UID,
        // Trade ID -> Trade details
        trades: Table<vector<u8>, Trade>,
        // System state
        is_paused: bool,
        // Statistics
        total_trades_created: u64,
        total_trades_completed: u64,
        total_trades_cancelled: u64,
        total_trades_disputed: u64,
        total_cusd_volume: u64,
        total_confio_volume: u64
    }

    struct Trade has store, copy, drop {
        // Trade participants
        seller: address,
        buyer: address,
        // Trade details
        amount: u64,
        token_type: vector<u8>, // "CUSD" or "CONFIO"
        // Fiat details (stored in Django, just reference here)
        fiat_amount: u64,
        fiat_currency: vector<u8>, // e.g., "VES", "ARS", "USD"
        // Timestamps
        created_at: u64,
        expires_at: u64,
        accepted_at: u64,
        // Status
        status: u8,
        // Dispute info
        dispute_reason: vector<u8>,
        dispute_opened_by: address,
        dispute_opened_at: u64
    }

    // Escrow vault to hold funds
    struct EscrowVault has key {
        id: UID,
        cusd_balances: Table<vector<u8>, Balance<CUSD>>,
        confio_balances: Table<vector<u8>, Balance<CONFIO>>
    }

    // Events
    struct TradeCreated has copy, drop {
        trade_id: vector<u8>,
        seller: address,
        amount: u64,
        token_type: vector<u8>,
        fiat_amount: u64,
        fiat_currency: vector<u8>,
        expires_at: u64,
        timestamp: u64
    }

    struct TradeAccepted has copy, drop {
        trade_id: vector<u8>,
        buyer: address,
        timestamp: u64
    }

    struct TradeCompleted has copy, drop {
        trade_id: vector<u8>,
        seller: address,
        buyer: address,
        amount: u64,
        token_type: vector<u8>,
        timestamp: u64
    }

    struct TradeCancelled has copy, drop {
        trade_id: vector<u8>,
        cancelled_by: address,
        reason: vector<u8>,
        timestamp: u64
    }

    struct DisputeOpened has copy, drop {
        trade_id: vector<u8>,
        opened_by: address,
        reason: vector<u8>,
        timestamp: u64
    }

    struct DisputeResolved has copy, drop {
        trade_id: vector<u8>,
        resolved_by: address,
        winner: address,
        timestamp: u64
    }

    struct TradeExpired has copy, drop {
        trade_id: vector<u8>,
        timestamp: u64
    }

    // Initialize
    fun init(ctx: &mut TxContext) {
        let admin_cap = AdminCap {
            id: object::new(ctx)
        };
        
        let registry = TradeRegistry {
            id: object::new(ctx),
            trades: table::new(ctx),
            is_paused: false,
            total_trades_created: 0,
            total_trades_completed: 0,
            total_trades_cancelled: 0,
            total_trades_disputed: 0,
            total_cusd_volume: 0,
            total_confio_volume: 0
        };

        let vault = EscrowVault {
            id: object::new(ctx),
            cusd_balances: table::new(ctx),
            confio_balances: table::new(ctx)
        };

        transfer::transfer(admin_cap, sender(ctx));
        share_object(registry);
        share_object(vault);
    }

    // Create a new P2P trade offer (seller deposits crypto)
    public entry fun create_cusd_trade(
        registry: &mut TradeRegistry,
        vault: &mut EscrowVault,
        clock: &Clock,
        payment: Coin<CUSD>,
        trade_id: vector<u8>, // Generated by Django
        fiat_amount: u64,
        fiat_currency: vector<u8>,
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(!table::contains(&registry.trades, trade_id), ETradeNotFound);
        
        let amount = coin::value(&payment);
        assert!(amount > 0, EInvalidAmount);
        
        let current_time = clock::timestamp_ms(clock);
        let expires_at = current_time + TRADE_WINDOW_MS;
        
        // Create trade record
        let trade = Trade {
            seller: sender(ctx),
            buyer: @0x0, // Will be set when accepted
            amount,
            token_type: b"CUSD",
            fiat_amount,
            fiat_currency,
            created_at: current_time,
            expires_at,
            accepted_at: 0,
            status: STATUS_PENDING,
            dispute_reason: vector::empty(),
            dispute_opened_by: @0x0,
            dispute_opened_at: 0
        };
        
        // Store trade
        table::add(&mut registry.trades, trade_id, trade);
        
        // Escrow the funds
        let balance = coin::into_balance(payment);
        table::add(&mut vault.cusd_balances, trade_id, balance);
        
        // Update statistics
        registry.total_trades_created = registry.total_trades_created + 1;
        
        // Emit event
        event::emit(TradeCreated {
            trade_id,
            seller: sender(ctx),
            amount,
            token_type: b"CUSD",
            fiat_amount,
            fiat_currency,
            expires_at,
            timestamp: current_time
        });
    }

    // Create CONFIO trade
    public entry fun create_confio_trade(
        registry: &mut TradeRegistry,
        vault: &mut EscrowVault,
        clock: &Clock,
        payment: Coin<CONFIO>,
        trade_id: vector<u8>,
        fiat_amount: u64,
        fiat_currency: vector<u8>,
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(!table::contains(&registry.trades, trade_id), ETradeNotFound);
        
        let amount = coin::value(&payment);
        assert!(amount > 0, EInvalidAmount);
        
        let current_time = clock::timestamp_ms(clock);
        let expires_at = current_time + TRADE_WINDOW_MS;
        
        // Create trade record
        let trade = Trade {
            seller: sender(ctx),
            buyer: @0x0,
            amount,
            token_type: b"CONFIO",
            fiat_amount,
            fiat_currency,
            created_at: current_time,
            expires_at,
            accepted_at: 0,
            status: STATUS_PENDING,
            dispute_reason: vector::empty(),
            dispute_opened_by: @0x0,
            dispute_opened_at: 0
        };
        
        // Store trade
        table::add(&mut registry.trades, trade_id, trade);
        
        // Escrow the funds
        let balance = coin::into_balance(payment);
        table::add(&mut vault.confio_balances, trade_id, balance);
        
        // Update statistics
        registry.total_trades_created = registry.total_trades_created + 1;
        
        // Emit event
        event::emit(TradeCreated {
            trade_id,
            seller: sender(ctx),
            amount,
            token_type: b"CONFIO",
            fiat_amount,
            fiat_currency,
            expires_at,
            timestamp: current_time
        });
    }

    // Buyer accepts the trade
    public entry fun accept_trade(
        registry: &mut TradeRegistry,
        clock: &Clock,
        trade_id: vector<u8>,
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(table::contains(&registry.trades, trade_id), ETradeNotFound);
        
        let trade = table::borrow_mut(&mut registry.trades, trade_id);
        assert!(trade.status == STATUS_PENDING, EInvalidTradeState);
        assert!(trade.seller != sender(ctx), ESelfTrade);
        
        let current_time = clock::timestamp_ms(clock);
        assert!(current_time <= trade.expires_at, ETradeExpired);
        
        // Update trade
        trade.buyer = sender(ctx);
        trade.status = STATUS_ACTIVE;
        trade.accepted_at = current_time;
        
        // Emit event
        event::emit(TradeAccepted {
            trade_id,
            buyer: sender(ctx),
            timestamp: current_time
        });
    }

    // Seller confirms payment received
    public entry fun confirm_payment_received(
        registry: &mut TradeRegistry,
        vault: &mut EscrowVault,
        clock: &Clock,
        trade_id: vector<u8>,
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(table::contains(&registry.trades, trade_id), ETradeNotFound);
        
        let trade = table::borrow_mut(&mut registry.trades, trade_id);
        assert!(trade.seller == sender(ctx), ENotAuthorized);
        assert!(trade.status == STATUS_ACTIVE, EInvalidTradeState);
        
        let current_time = clock::timestamp_ms(clock);
        
        // Mark as completed
        trade.status = STATUS_COMPLETED;
        
        // Release funds to buyer
        let buyer = trade.buyer;
        let amount = trade.amount;
        let token_type = trade.token_type;
        
        if (token_type == b"CUSD") {
            let balance = table::remove(&mut vault.cusd_balances, trade_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, buyer);
            
            registry.total_cusd_volume = registry.total_cusd_volume + amount;
        } else {
            let balance = table::remove(&mut vault.confio_balances, trade_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, buyer);
            
            registry.total_confio_volume = registry.total_confio_volume + amount;
        };
        
        registry.total_trades_completed = registry.total_trades_completed + 1;
        
        // Emit event
        event::emit(TradeCompleted {
            trade_id,
            seller: trade.seller,
            buyer,
            amount,
            token_type,
            timestamp: current_time
        });
    }

    // Cancel trade (by seller before acceptance or after expiry)
    public entry fun cancel_trade(
        registry: &mut TradeRegistry,
        vault: &mut EscrowVault,
        clock: &Clock,
        trade_id: vector<u8>,
        reason: vector<u8>,
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(table::contains(&registry.trades, trade_id), ETradeNotFound);
        
        let trade = table::borrow_mut(&mut registry.trades, trade_id);
        let current_time = clock::timestamp_ms(clock);
        
        // Check authorization and conditions
        if (trade.status == STATUS_PENDING) {
            // Seller can cancel pending trade
            assert!(trade.seller == sender(ctx), ENotAuthorized);
        } else if (trade.status == STATUS_ACTIVE && current_time > trade.expires_at) {
            // Anyone can cancel expired active trade
        } else {
            abort EInvalidTradeState
        };
        
        // Mark as cancelled
        trade.status = STATUS_CANCELLED;
        
        // Return funds to seller
        let seller = trade.seller;
        let token_type = trade.token_type;
        
        if (token_type == b"CUSD") {
            let balance = table::remove(&mut vault.cusd_balances, trade_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, seller);
        } else {
            let balance = table::remove(&mut vault.confio_balances, trade_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, seller);
        };
        
        registry.total_trades_cancelled = registry.total_trades_cancelled + 1;
        
        // Emit event
        event::emit(TradeCancelled {
            trade_id,
            cancelled_by: sender(ctx),
            reason,
            timestamp: current_time
        });
    }

    // Open dispute (by buyer or seller)
    public entry fun open_dispute(
        registry: &mut TradeRegistry,
        clock: &Clock,
        trade_id: vector<u8>,
        reason: vector<u8>,
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(table::contains(&registry.trades, trade_id), ETradeNotFound);
        
        let trade = table::borrow_mut(&mut registry.trades, trade_id);
        assert!(trade.status == STATUS_ACTIVE, EInvalidTradeState);
        assert!(trade.seller == sender(ctx) || trade.buyer == sender(ctx), ENotAuthorized);
        
        let current_time = clock::timestamp_ms(clock);
        
        // Mark as disputed
        trade.status = STATUS_DISPUTED;
        trade.dispute_reason = reason;
        trade.dispute_opened_by = sender(ctx);
        trade.dispute_opened_at = current_time;
        
        registry.total_trades_disputed = registry.total_trades_disputed + 1;
        
        // Emit event
        event::emit(DisputeOpened {
            trade_id,
            opened_by: sender(ctx),
            reason,
            timestamp: current_time
        });
    }

    // Resolve dispute (admin only)
    public entry fun resolve_dispute(
        _admin: &AdminCap,
        registry: &mut TradeRegistry,
        vault: &mut EscrowVault,
        clock: &Clock,
        trade_id: vector<u8>,
        winner: address, // Either seller or buyer
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(table::contains(&registry.trades, trade_id), ETradeNotFound);
        
        let trade = table::borrow_mut(&mut registry.trades, trade_id);
        assert!(trade.status == STATUS_DISPUTED, ETradeNotInDispute);
        assert!(winner == trade.seller || winner == trade.buyer, ENotAuthorized);
        
        let current_time = clock::timestamp_ms(clock);
        
        // Mark as completed
        trade.status = STATUS_COMPLETED;
        
        // Release funds to winner
        let amount = trade.amount;
        let token_type = trade.token_type;
        
        if (token_type == b"CUSD") {
            let balance = table::remove(&mut vault.cusd_balances, trade_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, winner);
            
            if (winner == trade.buyer) {
                registry.total_cusd_volume = registry.total_cusd_volume + amount;
            };
        } else {
            let balance = table::remove(&mut vault.confio_balances, trade_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, winner);
            
            if (winner == trade.buyer) {
                registry.total_confio_volume = registry.total_confio_volume + amount;
            };
        };
        
        registry.total_trades_completed = registry.total_trades_completed + 1;
        
        // Emit event
        event::emit(DisputeResolved {
            trade_id,
            resolved_by: sender(ctx),
            winner,
            timestamp: current_time
        });
    }

    // Admin functions
    public entry fun pause(_admin: &AdminCap, registry: &mut TradeRegistry, _ctx: &mut TxContext) {
        assert!(!registry.is_paused, ESystemPaused);
        registry.is_paused = true;
    }

    public entry fun unpause(_admin: &AdminCap, registry: &mut TradeRegistry, _ctx: &mut TxContext) {
        assert!(registry.is_paused, ESystemPaused);
        registry.is_paused = false;
    }

    // View functions
    public fun get_trade(registry: &TradeRegistry, trade_id: vector<u8>): &Trade {
        assert!(table::contains(&registry.trades, trade_id), ETradeNotFound);
        table::borrow(&registry.trades, trade_id)
    }

    public fun is_trade_expired(
        registry: &TradeRegistry,
        clock: &Clock,
        trade_id: vector<u8>
    ): bool {
        if (!table::contains(&registry.trades, trade_id)) {
            return false
        };
        
        let trade = table::borrow(&registry.trades, trade_id);
        let current_time = clock::timestamp_ms(clock);
        
        current_time > trade.expires_at
    }

    public fun get_stats(registry: &TradeRegistry): (u64, u64, u64, u64, u64, u64) {
        (
            registry.total_trades_created,
            registry.total_trades_completed,
            registry.total_trades_cancelled,
            registry.total_trades_disputed,
            registry.total_cusd_volume,
            registry.total_confio_volume
        )
    }

    // Test only
    #[test_only]
    public fun test_init(ctx: &mut TxContext) {
        init(ctx)
    }
}