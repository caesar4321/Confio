module invite_send::invite_send {
    use sui::object::{Self, UID};
    use sui::tx_context::{Self, sender, TxContext};
    use sui::transfer::{Self, public_transfer, share_object};
    use sui::coin::{Self, Coin};
    use sui::balance::{Balance};
    use sui::event;
    use sui::clock::{Self, Clock};
    use sui::table::{Self, Table};
    use cusd::cusd::CUSD;
    use confio::confio::CONFIO;

    // Error codes
    const ENotAuthorized: u64 = 1;
    const EInvalidAmount: u64 = 2;
    const EInvitationNotFound: u64 = 3;
    const EInvitationAlreadyClaimed: u64 = 4;
    const EInvitationExpired: u64 = 5;
    const EInvitationNotExpired: u64 = 6;
    const ESystemPaused: u64 = 7;

    // Constants
    const RECLAIM_PERIOD_MS: u64 = 604800000; // 7 days in milliseconds

    // Objects
    struct AdminCap has key, store {
        id: UID
    }

    struct InvitationRegistry has key {
        id: UID,
        // Invitation ID -> Invitation details
        invitations: Table<vector<u8>, Invitation>,
        // System state
        is_paused: bool,
        // Statistics
        total_invitations_created: u64,
        total_invitations_claimed: u64,
        total_invitations_reclaimed: u64,
        total_cusd_locked: u64,
        total_confio_locked: u64
    }

    struct Invitation has store, copy, drop {
        // Sender information
        sender: address,
        // Amount locked
        amount: u64,
        // Token type: "CUSD" or "CONFIO"
        token_type: vector<u8>,
        // Creation timestamp
        created_at: u64,
        // Expiry timestamp (created_at + 7 days)
        expires_at: u64,
        // Status
        is_claimed: bool,
        is_reclaimed: bool,
        // Optional message from sender
        message: vector<u8>
    }

    // Store actual balances separately to avoid storing Coin objects in Table
    struct InvitationVault has key {
        id: UID,
        cusd_balances: Table<vector<u8>, Balance<CUSD>>,
        confio_balances: Table<vector<u8>, Balance<CONFIO>>
    }

    // Events
    struct InvitationCreated has copy, drop {
        invitation_id: vector<u8>,
        sender: address,
        amount: u64,
        token_type: vector<u8>,
        expires_at: u64,
        message: vector<u8>,
        timestamp: u64
    }

    struct InvitationClaimed has copy, drop {
        invitation_id: vector<u8>,
        sender: address,
        recipient: address,
        amount: u64,
        token_type: vector<u8>,
        timestamp: u64
    }

    struct InvitationReclaimed has copy, drop {
        invitation_id: vector<u8>,
        sender: address,
        amount: u64,
        token_type: vector<u8>,
        timestamp: u64
    }

    struct SystemPaused has copy, drop {
        timestamp: u64
    }

    struct SystemUnpaused has copy, drop {
        timestamp: u64
    }

    // Initialize
    fun init(ctx: &mut TxContext) {
        let admin_cap = AdminCap {
            id: object::new(ctx)
        };
        
        let registry = InvitationRegistry {
            id: object::new(ctx),
            invitations: table::new(ctx),
            is_paused: false,
            total_invitations_created: 0,
            total_invitations_claimed: 0,
            total_invitations_reclaimed: 0,
            total_cusd_locked: 0,
            total_confio_locked: 0
        };

        let vault = InvitationVault {
            id: object::new(ctx),
            cusd_balances: table::new(ctx),
            confio_balances: table::new(ctx)
        };

        transfer::transfer(admin_cap, sender(ctx));
        share_object(registry);
        share_object(vault);
    }

    // Create invitation with cUSD
    public entry fun create_cusd_invitation(
        registry: &mut InvitationRegistry,
        vault: &mut InvitationVault,
        clock: &Clock,
        payment: Coin<CUSD>,
        invitation_id: vector<u8>, // Generated by Django (e.g., UUID)
        message: vector<u8>,
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(!table::contains(&registry.invitations, invitation_id), EInvitationNotFound);
        
        let amount = coin::value(&payment);
        assert!(amount > 0, EInvalidAmount);
        
        let current_time = clock::timestamp_ms(clock);
        let expires_at = current_time + RECLAIM_PERIOD_MS;
        
        // Create invitation record
        let invitation = Invitation {
            sender: sender(ctx),
            amount,
            token_type: b"CUSD",
            created_at: current_time,
            expires_at,
            is_claimed: false,
            is_reclaimed: false,
            message
        };
        
        // Store invitation
        table::add(&mut registry.invitations, invitation_id, invitation);
        
        // Store the balance
        let balance = coin::into_balance(payment);
        table::add(&mut vault.cusd_balances, invitation_id, balance);
        
        // Update statistics
        registry.total_invitations_created = registry.total_invitations_created + 1;
        registry.total_cusd_locked = registry.total_cusd_locked + amount;
        
        // Emit event
        event::emit(InvitationCreated {
            invitation_id,
            sender: sender(ctx),
            amount,
            token_type: b"CUSD",
            expires_at,
            message,
            timestamp: current_time
        });
    }

    // Create invitation with CONFIO
    public entry fun create_confio_invitation(
        registry: &mut InvitationRegistry,
        vault: &mut InvitationVault,
        clock: &Clock,
        payment: Coin<CONFIO>,
        invitation_id: vector<u8>,
        message: vector<u8>,
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(!table::contains(&registry.invitations, invitation_id), EInvitationNotFound);
        
        let amount = coin::value(&payment);
        assert!(amount > 0, EInvalidAmount);
        
        let current_time = clock::timestamp_ms(clock);
        let expires_at = current_time + RECLAIM_PERIOD_MS;
        
        // Create invitation record
        let invitation = Invitation {
            sender: sender(ctx),
            amount,
            token_type: b"CONFIO",
            created_at: current_time,
            expires_at,
            is_claimed: false,
            is_reclaimed: false,
            message
        };
        
        // Store invitation
        table::add(&mut registry.invitations, invitation_id, invitation);
        
        // Store the balance
        let balance = coin::into_balance(payment);
        table::add(&mut vault.confio_balances, invitation_id, balance);
        
        // Update statistics
        registry.total_invitations_created = registry.total_invitations_created + 1;
        registry.total_confio_locked = registry.total_confio_locked + amount;
        
        // Emit event
        event::emit(InvitationCreated {
            invitation_id,
            sender: sender(ctx),
            amount,
            token_type: b"CONFIO",
            expires_at,
            message,
            timestamp: current_time
        });
    }

    // Admin claims invitation on behalf of verified user
    public entry fun claim_invitation(
        _admin: &AdminCap,
        registry: &mut InvitationRegistry,
        vault: &mut InvitationVault,
        clock: &Clock,
        invitation_id: vector<u8>,
        recipient: address, // New user's Sui address from zkLogin
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(table::contains(&registry.invitations, invitation_id), EInvitationNotFound);
        
        let invitation = table::borrow_mut(&mut registry.invitations, invitation_id);
        assert!(!invitation.is_claimed, EInvitationAlreadyClaimed);
        assert!(!invitation.is_reclaimed, EInvitationAlreadyClaimed);
        
        let current_time = clock::timestamp_ms(clock);
        assert!(current_time <= invitation.expires_at, EInvitationExpired);
        
        // Mark as claimed
        invitation.is_claimed = true;
        
        // Get amount and token type
        let amount = invitation.amount;
        let token_type = invitation.token_type;
        let sender = invitation.sender;
        
        // Transfer funds based on token type
        if (token_type == b"CUSD") {
            let balance = table::remove(&mut vault.cusd_balances, invitation_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, recipient);
            
            // Update statistics
            registry.total_cusd_locked = registry.total_cusd_locked - amount;
        } else {
            let balance = table::remove(&mut vault.confio_balances, invitation_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, recipient);
            
            // Update statistics
            registry.total_confio_locked = registry.total_confio_locked - amount;
        };
        
        registry.total_invitations_claimed = registry.total_invitations_claimed + 1;
        
        // Emit event
        event::emit(InvitationClaimed {
            invitation_id,
            sender,
            recipient,
            amount,
            token_type,
            timestamp: current_time
        });
    }

    // Sender reclaims expired invitation
    public entry fun reclaim_invitation(
        registry: &mut InvitationRegistry,
        vault: &mut InvitationVault,
        clock: &Clock,
        invitation_id: vector<u8>,
        ctx: &mut TxContext
    ) {
        assert!(!registry.is_paused, ESystemPaused);
        assert!(table::contains(&registry.invitations, invitation_id), EInvitationNotFound);
        
        let invitation = table::borrow_mut(&mut registry.invitations, invitation_id);
        assert!(invitation.sender == sender(ctx), ENotAuthorized);
        assert!(!invitation.is_claimed, EInvitationAlreadyClaimed);
        assert!(!invitation.is_reclaimed, EInvitationAlreadyClaimed);
        
        let current_time = clock::timestamp_ms(clock);
        assert!(current_time > invitation.expires_at, EInvitationNotExpired);
        
        // Mark as reclaimed
        invitation.is_reclaimed = true;
        
        // Get amount and token type
        let amount = invitation.amount;
        let token_type = invitation.token_type;
        
        // Return funds to sender
        if (token_type == b"CUSD") {
            let balance = table::remove(&mut vault.cusd_balances, invitation_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, sender(ctx));
            
            // Update statistics
            registry.total_cusd_locked = registry.total_cusd_locked - amount;
        } else {
            let balance = table::remove(&mut vault.confio_balances, invitation_id);
            let coin = coin::from_balance(balance, ctx);
            public_transfer(coin, sender(ctx));
            
            // Update statistics
            registry.total_confio_locked = registry.total_confio_locked - amount;
        };
        
        registry.total_invitations_reclaimed = registry.total_invitations_reclaimed + 1;
        
        // Emit event
        event::emit(InvitationReclaimed {
            invitation_id,
            sender: sender(ctx),
            amount,
            token_type,
            timestamp: current_time
        });
    }

    // Admin functions
    public entry fun pause(_admin: &AdminCap, registry: &mut InvitationRegistry, ctx: &mut TxContext) {
        assert!(!registry.is_paused, ESystemPaused);
        registry.is_paused = true;
        
        event::emit(SystemPaused {
            timestamp: tx_context::epoch_timestamp_ms(ctx)
        });
    }

    public entry fun unpause(_admin: &AdminCap, registry: &mut InvitationRegistry, ctx: &mut TxContext) {
        assert!(registry.is_paused, ESystemPaused);
        registry.is_paused = false;
        
        event::emit(SystemUnpaused {
            timestamp: tx_context::epoch_timestamp_ms(ctx)
        });
    }

    // View functions
    public fun get_invitation(registry: &InvitationRegistry, invitation_id: vector<u8>): &Invitation {
        assert!(table::contains(&registry.invitations, invitation_id), EInvitationNotFound);
        table::borrow(&registry.invitations, invitation_id)
    }

    public fun is_invitation_claimable(
        registry: &InvitationRegistry, 
        clock: &Clock,
        invitation_id: vector<u8>
    ): bool {
        if (!table::contains(&registry.invitations, invitation_id)) {
            return false
        };
        
        let invitation = table::borrow(&registry.invitations, invitation_id);
        let current_time = clock::timestamp_ms(clock);
        
        !invitation.is_claimed && 
        !invitation.is_reclaimed && 
        current_time <= invitation.expires_at
    }

    public fun is_invitation_reclaimable(
        registry: &InvitationRegistry, 
        clock: &Clock,
        invitation_id: vector<u8>,
        sender_address: address
    ): bool {
        if (!table::contains(&registry.invitations, invitation_id)) {
            return false
        };
        
        let invitation = table::borrow(&registry.invitations, invitation_id);
        let current_time = clock::timestamp_ms(clock);
        
        invitation.sender == sender_address &&
        !invitation.is_claimed && 
        !invitation.is_reclaimed && 
        current_time > invitation.expires_at
    }

    public fun get_stats(registry: &InvitationRegistry): (u64, u64, u64, u64, u64) {
        (
            registry.total_invitations_created,
            registry.total_invitations_claimed,
            registry.total_invitations_reclaimed,
            registry.total_cusd_locked,
            registry.total_confio_locked
        )
    }
}